"""Utilities for provisioning and retrieving Document Signer certificates.

The Document Signer (DSC) certificate is required for:

* Embedding inside SOD structures generated by the passport personalization
  pipeline.
* Verifying signatures on SODs, DTC payloads, and other artifacts produced by
  the document_signer service.

This helper ensures that a consistent certificate exists for the configured
signing key. When none is present, it issues a self-signed certificate bound to
that key and persists it via the shared ``CertificateRepository``.
"""

from __future__ import annotations

from datetime import datetime, timedelta, timezone
from typing import Optional

from cryptography import x509
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.x509.oid import ExtendedKeyUsageOID
from sqlalchemy.ext.asyncio import AsyncSession

from src.marty_common.infrastructure import CertificateRepository, KeyVaultClient

DOCUMENT_SIGNER_CERT_ID = "document-signer-default-dsc"
DOCUMENT_SIGNER_SUBJECT = "CN=Document Signer,O=Marty Labs"
DOCUMENT_SIGNER_KEY_ID = "document-signer-default"


async def ensure_document_signer_certificate(
    session: AsyncSession,
    key_vault: KeyVaultClient,
    certificate_id: str = DOCUMENT_SIGNER_CERT_ID,
    subject_dn: str = DOCUMENT_SIGNER_SUBJECT,
    key_id: str = DOCUMENT_SIGNER_KEY_ID,
    validity_years: int = 5,
) -> x509.Certificate:
    """Ensure that a DSC exists for the given signing key and return it."""
    repository = CertificateRepository(session)
    record = await repository.get(certificate_id)
    if record:
        return x509.load_pem_x509_certificate(record.pem.encode("utf-8"))

    # Make sure key material exists
    await key_vault.ensure_key(key_id, "rsa2048")
    private_key_pem = await key_vault.load_private_key(key_id)
    private_key = serialization.load_pem_private_key(private_key_pem, password=None)
    if not isinstance(private_key, rsa.RSAPrivateKey):
        msg = "Document signer key must be RSA"
        raise TypeError(msg)

    subject = issuer = x509.Name.from_rfc4514_string(subject_dn)

    now = datetime.now(timezone.utc)
    certificate_builder = (
        x509.CertificateBuilder()
        .subject_name(subject)
        .issuer_name(issuer)
        .public_key(private_key.public_key())
        .serial_number(x509.random_serial_number())
        .not_valid_before(now)
        .not_valid_after(now + timedelta(days=365 * validity_years))
        .add_extension(x509.BasicConstraints(ca=False, path_length=None), critical=True)
        .add_extension(
            x509.KeyUsage(
                digital_signature=True,
                content_commitment=False,
                key_encipherment=False,
                data_encipherment=False,
                key_agreement=False,
                key_cert_sign=False,
                crl_sign=False,
                encipher_only=False,
                decipher_only=False,
            ),
            critical=True,
        )
        .add_extension(
            x509.ExtendedKeyUsage([
                ExtendedKeyUsageOID.CODE_SIGNING,
                ExtendedKeyUsageOID.EMAIL_PROTECTION,
            ]),
            critical=False,
        )
        .add_extension(
            x509.SubjectKeyIdentifier.from_public_key(private_key.public_key()),
            critical=False,
        )
    )

    certificate = certificate_builder.sign(private_key=private_key, algorithm=hashes.SHA256())
    pem_text = certificate.public_bytes(serialization.Encoding.PEM).decode("utf-8")

    details = {
        "issued_at": now.isoformat(),
        "not_after": (now + timedelta(days=365 * validity_years)).isoformat(),
        "key_id": key_id,
    }

    await repository.upsert(
        cert_id=certificate_id,
        cert_type="DSC",
        pem=pem_text,
        issuer=subject_dn,
        subject=subject_dn,
        details=details,
    )

    return certificate


async def get_document_signer_certificate(
    session: AsyncSession,
    certificate_id: str = DOCUMENT_SIGNER_CERT_ID,
) -> Optional[x509.Certificate]:
    """Fetch an existing DSC from the repository if present."""
    repository = CertificateRepository(session)
    record = await repository.get(certificate_id)
    if record is None:
        return None
    return x509.load_pem_x509_certificate(record.pem.encode("utf-8"))


async def load_or_create_document_signer_certificate(
    session: AsyncSession,
    key_vault: KeyVaultClient,
) -> x509.Certificate:
    """Convenience helper that loads the DSC or provisions a new one."""
    certificate = await get_document_signer_certificate(session)
    if certificate:
        return certificate
    return await ensure_document_signer_certificate(session, key_vault)


__all__ = [
    "DOCUMENT_SIGNER_CERT_ID",
    "DOCUMENT_SIGNER_SUBJECT",
    "DOCUMENT_SIGNER_KEY_ID",
    "ensure_document_signer_certificate",
    "get_document_signer_certificate",
    "load_or_create_document_signer_certificate",
]
