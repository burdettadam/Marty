"""
Orchestrator-Compatible Integration Test Base Class

This module provides a base class for integration tests th            except ValueError:
                # Service doesn't exist in orchestrator - re-raise immediately
                logger.exception("Service lookup failed")
                raiset wor        # Use class-level SERVICE_PORTS directly
        for service_name in self.SERVICE_PORTS.keys():
            try:
                address = self.get_service_address(service_name)
                services[service_name] = address
            except ValueError:
                # Service not available
                continuehe TestOrchestrator system instead of managing Docker services directly.
"""

import logging
import time
import unittest
from pathlib import Path
from typing import ClassVar

import grpc

# Configure logging
logger = logging.getLogger(__name__)


class OrchestratedIntegrationTest(unittest.TestCase):
    """Base class for integration tests that use orchestrated services."""

    # Service port mappings (should match TestOrchestrator configuration)
    SERVICE_PORTS: ClassVar[dict[str, int]] = {
        "postgres": 5432,
        "trust-anchor": 9080,
        "csca-service": 8081,
        "document-signer": 8082,
        "inspection-system": 8083,
        "passport-engine": 8084,
        "mdl-engine": 8085,
        "mdoc-engine": 8086,
        "dtc-engine": 8087,
        "pkd-service": 8088
    }

    def setUp(self):
        """Set up test fixtures."""
        super().setUp()
        self.project_root = Path(__file__).resolve().parents[4]

    def get_service_address(self, service_name: str, host: str = "localhost") -> str:
        """Get the service address for a given service.

        Args:
            service_name: Name of the service (e.g., 'csca-service')
            host: Host address (defaults to localhost)

        Returns:
            Full service address (e.g., 'localhost:8081')
        """
        port = self.SERVICE_PORTS.get(service_name)
        if not port:
            # Try with underscores instead of hyphens
            service_name_alt = service_name.replace("-", "_")
            port = self.SERVICE_PORTS.get(service_name_alt)

        if not port:
            msg = f"Unknown service: {service_name}"
            raise ValueError(msg)

        return f"{host}:{port}"

    def get_grpc_channel(self, service_name: str, host: str = "localhost") -> grpc.Channel:
        """Get a gRPC channel for the specified service.

        Args:
            service_name: Name of the service
            host: Host address (defaults to localhost)

        Returns:
            gRPC channel for the service
        """
        address = self.get_service_address(service_name, host)
        return grpc.insecure_channel(address)

    def wait_for_service_ready(self, service_name: str, timeout: int = 30) -> bool:
        """Wait for a service to be ready with exponential backoff.

        Args:
            service_name: Name of the service to wait for
            timeout: Maximum time to wait in seconds

        Returns:
            True if service is ready, False if timeout

        Raises:
            ValueError: If service_name is not known to the orchestrator
        """
        start_time = time.time()
        delay = 1  # Start with 1 second delay
        max_delay = 8  # Maximum delay between retries
        
        while time.time() - start_time < timeout:
            try:
                with self.get_grpc_channel(service_name) as channel:
                    try:
                        # Test channel readiness with shorter timeout for each attempt
                        remaining_time = timeout - (time.time() - start_time)
                        grpc.channel_ready_future(channel).result(timeout=min(2, remaining_time))
                        logger.info("Service %s is ready", service_name)
                    except grpc.FutureTimeoutError:
                        # Service exists but not ready - wait and retry
                        logger.debug("Service %s not ready, retrying in %ds", service_name, delay)
                    except (grpc.RpcError, OSError) as e:
                        logger.debug("Service %s connection failed: %s, retrying in %ds",
                                   service_name, e, delay)
                    else:
                        return True
            except ValueError:\n                # Service doesn't exist in orchestrator - re-raise immediately\n                logger.exception(\"Service lookup failed\")\n                raise
            
            # Common backoff logic for both timeout and connection errors
            time.sleep(delay)
            delay = min(delay * 1.5, max_delay)  # Exponential backoff

        logger.warning("Service %s not ready after %ds", service_name, timeout)
        return False

    def assert_service_healthy(self, service_name: str, timeout: int = 30):
        """Assert that a service is healthy and ready.

        Args:
            service_name: Name of the service to check
            timeout: Maximum time to wait

        Raises:
            AssertionError: If service is not healthy
            ValueError: If service_name is not known to the orchestrator
        """
        if not self.wait_for_service_ready(service_name, timeout):
            self.fail(f"Service {service_name} is not healthy after {timeout}s")

    def get_all_service_addresses(self):
        """Get addresses for all available services.

        Returns:
            Dict mapping service names to their addresses
        """
        services = {}
        # Use class-level SERVICE_PORTS directly
        for service_name in self.SERVICE_PORTS.keys():
            try:
                address = self.get_service_address(service_name)
                services[service_name] = address
            except ValueError:
                # Service not available
                continue
        return services

    def wait_for_any_service_ready(self, service_names: list, timeout: int = 30):
        """Wait for any one of the specified services to be ready.

        Args:
            service_names: List of service names to check
            timeout: Maximum time to wait in seconds

        Returns:
            Name of the first service that becomes ready, or None if timeout
        """
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            for service_name in service_names:
                try:
                    if self.wait_for_service_ready(service_name, timeout=5):
                        logger.info("First available service: %s", service_name)
                        return service_name
                except ValueError:
                    # Service doesn't exist, try next one
                    continue
            
            # If no services are ready, wait a bit before trying again
            time.sleep(2)
        
        logger.warning("No services from %s became ready after %ds", service_names, timeout)
        return None

    def skip_if_no_services(self, required_services: list):
        """Skip the test if none of the required services are available.

        Args:
            required_services: List of service names that are required

        Raises:
            unittest.SkipTest: If no required services are available
        """
        available_services = []
        for service in required_services:
            try:
                # Just check if we can get the address (service is known)
                self.get_service_address(service)
                available_services.append(service)
            except ValueError:
                continue
        
        if not available_services:
            self.skipTest(f"None of the required services are available: {required_services}")
        
        logger.info("Available services for test: %s", available_services)
        return available_services
