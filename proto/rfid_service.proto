syntax = "proto3";

package marty.rfid.v1;

import "common_services.proto";

// RFID Reader Service for smart card and NFC operations
service RFIDReaderService {
    // Reader management
    rpc ListReaders(ListReadersRequest) returns (ListReadersResponse);
    rpc ConnectReader(ConnectReaderRequest) returns (ConnectReaderResponse);
    rpc DisconnectReader(DisconnectReaderRequest) returns (DisconnectReaderResponse);
    rpc GetReaderStatus(GetReaderStatusRequest) returns (GetReaderStatusResponse);
    
    // Card operations
    rpc ReadCard(ReadCardRequest) returns (ReadCardResponse);
    rpc SendAPDU(SendAPDURequest) returns (SendAPDUResponse);
    rpc GetATR(GetATRRequest) returns (GetATRResponse);
    
    // Document operations
    rpc ReadPassport(ReadPassportRequest) returns (ReadPassportResponse);
    rpc VerifyDocument(VerifyDocumentRequest) returns (VerifyDocumentResponse);
    rpc ExtractBiometrics(ExtractBiometricsRequest) returns (ExtractBiometricsResponse);
}

// Reader management messages
message ListReadersRequest {
    bool include_mock = 1;
}

message ListReadersResponse {
    repeated ReaderInfo readers = 1;
    marty.common.v1.Status status = 2;
}

message ReaderInfo {
    string name = 1;
    ReaderType type = 2;
    ReaderStatus status = 3;
    string atr = 4;  // Hex-encoded ATR
    string protocol = 5;
}

enum ReaderType {
    READER_TYPE_UNKNOWN = 0;
    READER_TYPE_PCSC = 1;
    READER_TYPE_ACR122U = 2;
    READER_TYPE_OMNIKEY = 3;
    READER_TYPE_MOCK = 4;
}

enum ReaderStatus {
    READER_STATUS_UNKNOWN = 0;
    READER_STATUS_DISCONNECTED = 1;
    READER_STATUS_CONNECTED = 2;
    READER_STATUS_BUSY = 3;
    READER_STATUS_ERROR = 4;
}

message ConnectReaderRequest {
    string reader_name = 1;
    int32 timeout_seconds = 2;
}

message ConnectReaderResponse {
    bool connected = 1;
    string atr = 2;  // Hex-encoded ATR
    marty.common.v1.Status status = 3;
}

message DisconnectReaderRequest {
    string reader_name = 1;
}

message DisconnectReaderResponse {
    bool disconnected = 1;
    marty.common.v1.Status status = 2;
}

message GetReaderStatusRequest {
    string reader_name = 1;
}

message GetReaderStatusResponse {
    ReaderInfo reader = 1;
    marty.common.v1.Status status = 2;
}

// Card operation messages
message ReadCardRequest {
    string reader_name = 1;
    repeated string data_groups = 2;  // DG1, DG2, etc.
}

message ReadCardResponse {
    map<string, bytes> data_groups = 1;  // DG name -> data
    marty.common.v1.Status status = 2;
}

message SendAPDURequest {
    string reader_name = 1;
    bytes apdu_command = 2;
}

message SendAPDUResponse {
    bytes apdu_response = 1;
    int32 sw1 = 2;
    int32 sw2 = 3;
    marty.common.v1.Status status = 4;
}

message GetATRRequest {
    string reader_name = 1;
}

message GetATRResponse {
    string atr = 1;  // Hex-encoded ATR
    marty.common.v1.Status status = 2;
}

// Document operation messages
message ReadPassportRequest {
    string reader_name = 1;
    MRZData mrz = 2;  // For BAC authentication
    repeated string requested_data_groups = 3;
}

message MRZData {
    string passport_number = 1;
    string date_of_birth = 2;  // YYMMDD
    string date_of_expiry = 3; // YYMMDD
}

message ReadPassportResponse {
    PassportData passport = 1;
    marty.common.v1.Status status = 2;
}

message PassportData {
    MRZInfo mrz_info = 1;
    map<string, bytes> data_groups = 2;
    SecurityData security = 3;
    BiometricData biometrics = 4;
}

message MRZInfo {
    string document_code = 1;
    string issuing_country = 2;
    string surname = 3;
    string given_names = 4;
    string passport_number = 5;
    string nationality = 6;
    string date_of_birth = 7;
    string sex = 8;
    string date_of_expiry = 9;
    string personal_number = 10;
    string check_digit_composite = 11;
}

message SecurityData {
    bytes sod_data = 1;  // Security Object Data
    bool signature_valid = 2;
    bool certificate_valid = 3;
    string issuing_ca = 4;
    repeated string certificate_chain = 5;
}

message BiometricData {
    bytes facial_image = 1;
    repeated bytes fingerprint_templates = 2;
    bytes iris_data = 3;
    repeated BiometricQuality quality_scores = 4;
}

message BiometricQuality {
    BiometricType type = 1;
    int32 quality_score = 2;  // 0-100
    string quality_details = 3;
}

enum BiometricType {
    BIOMETRIC_TYPE_UNKNOWN = 0;
    BIOMETRIC_TYPE_FACIAL = 1;
    BIOMETRIC_TYPE_FINGERPRINT = 2;
    BIOMETRIC_TYPE_IRIS = 3;
}

message VerifyDocumentRequest {
    string reader_name = 1;
    PassportData passport = 2;
    bool verify_biometrics = 3;
    bytes reference_image = 4;  // For biometric comparison
}

message VerifyDocumentResponse {
    VerificationResult result = 1;
    marty.common.v1.Status status = 2;
}

message VerificationResult {
    bool document_authentic = 1;
    bool cryptographic_valid = 2;
    bool biometric_match = 3;
    float biometric_score = 4;  // 0.0-1.0
    repeated string verification_details = 5;
    repeated string warnings = 6;
    repeated string errors = 7;
}

message ExtractBiometricsRequest {
    string reader_name = 1;
    repeated string biometric_types = 2;  // "facial", "fingerprint", "iris"
}

message ExtractBiometricsResponse {
    BiometricData biometrics = 1;
    marty.common.v1.Status status = 2;
}